<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>"Uzdevumi"</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../../reveal.js/css/reveal.css">
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../../reveal.js/css/print/pdf.css' : '../../reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="../../reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="section" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span style="color:darkgreen"><strong>(1) Ievads</strong></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup>
<!--
Meklēšana virknēs - 2
------
Ievads
Bojera-Mūra algoritms
BM algoritma piemēri
Dinamiskā programmēšana (Fibonači virknes; Daijkstras algoritms)
Rekursīvu algoritmu sarežģītība
Labošanas attālums
(P) Regulāru izteiksmju meklēšana
Kopsavilkums



Meklēšana virknēs - 3
------------
Ievads

Sufiksu koku jēdziens
Ukkonena algoritms
(P) Failu digitālnospiedumi (fingerprinting) un Blūma filtri
Kopsavilkums
--></section>
<section><section id="why" class="title-slide slide level1"><h1><lo-why/> why</h1><div class="bigWhy">
<p>Kāpēc jāizmanto dinamiskā programmēšana?</p>
</div>
<div class="smallWhy">
<ul>
<li>Dažiem optimizācijas uzdevumiem jādala uzdevums apakšuzdevumos.</li>
<li>Starprezultātu iegaumēšana var būtiski paātrināt dažus algoritmus.</li>
</ul>
</div></section><section id="nodarbības-mērķi" class="slide level2">
<h2><lo-summary/> Nodarbības mērķi</h2>
<ul>
<li>Aprakstīt Bojera Mūra algoritmu.</li>
<li>Aplūkot BM piemērus un darbības pareizību.</li>
<li>Salīdzināt rekursīvi definētas un iteratīvā ciklā definētas funkcijas (faktoriāli, Fibonači skaitļi)</li>
<li>Atgādināt Daikstras īsāko ceļu algoritmu.</li>
<li>Definēt Levenšteina attālumu 2 virknēm</li>
<li>Atrast Levenšteina attālumu ar dinamisko programmēšanu.</li>
<li>Atrast Levenšteina attālumu ar izmainītu Daikstras algoritmu.</li>
</ul>
</section></section>
<section id="section-1" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span style="color:darkgreen"><strong>(2) Bojera-Mūra algoritms</strong></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup></section>
<section><section id="stringu-meklēšana-atkārtojums" class="title-slide slide level1"><h1><lo-summary/> Stringu meklēšana: Atkārtojums</h1><p><strong>Uzdevums:</strong> Dots teksts <span class="math inline">\(T[0]\ldots{}T[n-1]\)</span> un meklējamais paraugs <span class="math inline">\(P[0]\ldots{}P[m-1]\)</span>; jāatrod visi gadījumi, kur <span class="math inline">\(P\)</span> ir <span class="math inline">\(T\)</span> apakšstrings (un jāizvada atbilstošās nobīdes).</p>
<p>Naivais un Knuta-Morisa-Prata algoritmi to dara, sākot ar pirmajiem simboliem (<span class="math inline">\(P[0]\)</span> un <span class="math inline">\(T[i]\)</span>, tad <span class="math inline">\(P[1]\)</span> un <span class="math inline">\(T[i+1]\)</span>, utt.). Ja kāds no burtiem atšķiras (piemēram, <span class="math inline">\(P[0] \neq T[i]\)</span>), tad salīdzināmo apakšvirkni pabīda vienu pozīciju tālāk: <span class="math inline">\(T[i]\ldots{}T[i-m-1]\)</span> vietā mēģina <span class="math inline">\(T[i+1]\ldots{}T[i-m]\)</span>.</p></section><section id="bojera-mūra-algoritma-pamatideja" class="slide level2">
<h2><lo-summary/> Bojera-Mūra algoritma pamatideja</h2>
<p>Bojera-Mūra algoritms sāk salīdzināšanu no pēdējā simbola (<span class="math inline">\(P[m-1]\)</span> un <span class="math inline">\(T[i+m-1]\)</span>). Nesakritības gadījumā salīdzināmo virkni var būt iespējams pabīdīt uz priekšu vairāk nekā par <span class="math inline">\(1\)</span> simbolu.<br />
Piemēram, ja <span class="math inline">\(T[i+m-1]\)</span> ir simbols, kas nesakrīt ne ar vienu no <span class="math inline">\(P[0],\ldots,P[m-1]\)</span>, tad varam pārbīdīt virkni par <span class="math inline">\(m\)</span> simboliem uz priekšu.</p>
<p>Tāpēc naivajam algoritmam un KMP vienmēr nepieciešamas <span class="math inline">\(O(n)\)</span> darbības, bet Bojera-Mūra algoritmam dažos gadījumos var pietikt ar <span class="math inline">\(O(n/m)\)</span> darbībām. (Sliktākajos gadījumos gan Bojera-Mūra algoritms nav labāks par KMP.)</p>
</section></section>
<section id="bojera-mūra-pseidokods" class="title-slide slide level1"><h1><lo-summary/> Bojera-Mūra pseidokods</h1><table class="pseudocode">
<tr>
<th colspan="2">
KMP_Matcher(<span class="math inline">\(T\)</span>, <span class="math inline">\(P\)</span>)
</th>
</tr>
<tr>
<td>
1
</td>
<td>
<span class="math inline">\(n = T.\mathit{length}\)</span>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<span class="math inline">\(m = P.\mathit{length}\)</span>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<span class="math inline">\(s = 0\)</span>
</td>
</tr>
<tr>
<td>
4
</td>
<td>
<b>while</b> <span class="math inline">\(s \leq n-m\)</span>
</td>
</tr>
<tr>
<td>
5
</td>
<td class="ind1">
<span class="math inline">\(j=m\)</span>
</td>
</tr>
<tr>
<td>
6
</td>
<td class="ind1">
<b>while</b> <span class="math inline">\(j&gt;0\)</span> <b>and</b> <span class="math inline">\(P[j-1] = T[s+j-1]\)</span> <b>do</b>
</td>
</tr>
<tr>
<td>
7
</td>
<td class="ind2">
<span class="math inline">\(j=j-1\)</span>
</td>
</tr>
<tr>
<td>
8
</td>
<td class="ind1">
<b>if</b> <span class="math inline">\(j=0\)</span> <b>then</b>
</td>
</tr>
<tr>
<td>
9
</td>
<td class="ind2">
print <tt style="font-family:'Courier New'">“Paraugs parādās ar nobīdi”</tt> <span class="math inline">\(s\)</span>
</td>
</tr>
<tr>
<td>
10
</td>
<td class="ind2">
<span class="math inline">\(s = s+ \gamma[0]\)</span>
</td>
</tr>
<tr>
<td>
11
</td>
<td class="ind1">
<b>else</b> <span class="math inline">\(s = s + \max(\gamma[j], j-1-\lambda[T[s+j-1]])\)</span>
</td>
</tr>
</table>
<div style="font-size:90%">
<p>Algoritma pārbīdes nosaka divas tabulas (<span class="math inline">\(\gamma\)</span> un <span class="math inline">\(\lambda\)</span>) - no abām pārbīdēm izvēlamies maksimālo. Šo tabulu konstruēšanu tūlīt aplūkosim.</p>
</div></section>
<section><section id="sliktā-simbola-tabula" class="title-slide slide level1"><h1><lo-summary/> Sliktā simbola tabula</h1><p>BM algoritms meklējamam paraugam <span class="math inline">\(P\)</span> izveido divus pārbīžu masīvus:<br />
sliktā simbola tabulu <span class="math inline">\(\lambda\)</span> un labā sufiksa tabulu <span class="math inline">\(\gamma\)</span>.</p>
<p>Sliktā simbola tabulu indeksē ar simboliem, kas var būt sastopami <span class="math inline">\(P\)</span>. Katram simbolam <span class="math inline">\(x\)</span> tajā ieraksta lielāko <span class="math inline">\(i\)</span>, kur <span class="math inline">\(P[i]=x\)</span>. Ja <span class="math inline">\(x\)</span> nav sastopams vārdā, tad <span class="math inline">\(\lambda[x]=-1\)</span>. Piemēram, ja <span class="math inline">\(P=\mathtt{abcab}\)</span>, tad tabula izskatās šādi:</p>
<table>
<tr>
<th>
<span class="math inline">\(x\)</span>
</th>
<td>
<span class="math inline">\(\mathtt{a}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{a}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{a}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{*}\)</span>
</td>
</tr>
<tr>
<th>
<span class="math inline">\(\lambda(x)\)</span>
</th>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(4\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(-1\)</span>
</td>
</tr>
</table>
<p>Ar <span class="math inline">\(\mathtt{*}\)</span> apzīmēts jebkurš simbols, kas nav <span class="math inline">\(\mathtt{a,b,c}\)</span>.</p></section><section id="sliktā-simbola-pseidokods" class="slide level2">
<h2><lo-summary/> Sliktā simbola pseidokods</h2>
<table class="pseudocode">
<tr>
<th colspan="2">
Bad_Character_Table(<span class="math inline">\(P\)</span>)
</th>
</tr>
<tr>
<td>
1
</td>
<td>
<b>for</b> <span class="math inline">\(a \in S\)</span>  <green>// katram alfabēta simbolam</green>
</td>
</tr>
<tr>
<td>
2
</td>
<td class="ind1">
<span class="math inline">\(\lambda[a] = -1\)</span>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<b>for</b> <span class="math inline">\(j=0\)</span> <b>to</b> <span class="math inline">\(m-1\)</span> <b>do</b>
</td>
</tr>
<tr>
<td>
4
</td>
<td class="ind1">
<span class="math inline">\(\lambda[P[j]] = j\)</span>
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<b>return</b> <span class="math inline">\(\lambda\)</span>
</td>
</tr>
</table>
</section></section>
<section><section id="labā-sufiksa-tabula" class="title-slide slide level1"><h1><lo-summary/> Labā sufiksa tabula</h1><p>Labā prefiksa tabulu <span class="math inline">\(\gamma[i]\)</span> indeksē ar skaitļiem <span class="math inline">\(i\)</span> no <span class="math inline">\(0\)</span> līdz <span class="math inline">\(m\)</span>. Šīs tabulas semantika ir šāda: ja <span class="math inline">\(P[i]\ldots{}P[m-1]\)</span> sakrīt ar <span class="math inline">\(T[k+i]\ldots{}T[k+m-1]\)</span>, bet <span class="math inline">\(P[i-1] \neq T[k+i-1]\)</span>, tad <span class="math inline">\(\gamma[i]\)</span> ir mazākā pārbīde <span class="math inline">\(j\)</span>, kuru ir vērts mēģināt.</p>
<ul>
<li>Ja <span class="math inline">\(i=m\)</span>, tad <span class="math inline">\(\gamma[i]=1\)</span>.</li>
<li>Ja <span class="math inline">\(i \leq m\)</span>, tad <span class="math inline">\(\gamma[i]\)</span> ir vienāds ar mazāko <span class="math inline">\(j&gt;0\)</span>, kam piemīt viena no šīm divām īpašībām:
<ul>
<li><span class="math inline">\(i \geq j\)</span> un <span class="math inline">\(P[i]\ldots{}P[m-1]\)</span> sakrīt ar <span class="math inline">\(P[i-j]\ldots{}P[m-j-1]\)</span>;</li>
<li><span class="math inline">\(i \leq j\)</span> un <span class="math inline">\(P[j]\ldots{}P[m-1]\)</span> sakrīt ar <span class="math inline">\(P[0]\ldots{}P[m-j-1]\)</span>. Ja tāds <span class="math inline">\(j\)</span> neeksistē, tad <span class="math inline">\(\gamma[i] = m\)</span>;</li>
</ul></li>
</ul></section><section id="labā-sufiksa-tabulas-piemērs" class="slide level2">
<h2><lo-summary/> Labā sufiksa tabulas piemērs</h2>
<p>Vārdam <span class="math inline">\(T = \mathtt{abcab}\)</span> labā sufiksa tabula izskatīsies šādi:</p>
<table>
<tr>
<th>
<span class="math inline">\(j\)</span>
</th>
<td>
<span class="math inline">\(5\)</span>
</td>
<td>
<span class="math inline">\(4\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(1\)</span>
</td>
<td>
<span class="math inline">\(0\)</span>
</td>
</tr>
<tr>
<th>
<span class="math inline">\(\gamma[j]\)</span>
</th>
<td>
<span class="math inline">\(1\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
</tr>
</table>
<p>Saturiski, tas nozīmē, ka ja nav sakritis pēdējais simbols, tad nākošā iespēja, kas jāmēģina ir <span class="math inline">\(T[i+1]\ldots{}T[i+5]\)</span>, bet, ja nav sakritis kāds no iepriekšējiem simboliem, tad varam uzreiz pāriet uz <span class="math inline">\(T[i+3]\ldots{}T[i+7]\)</span>.<br />
(Šajā gadījumā to mums garantē simbols <span class="math inline">\(P[4]=T[i+4]=\mathtt{b}\)</span>, jo <span class="math inline">\(\mathtt{b}\)</span> vārdā <span class="math inline">\(P\)</span> ir tikai <span class="math inline">\(P[4]\)</span> un <span class="math inline">\(P[1]\)</span>.)</p>
</section><section id="labā-sufiksa-tabulas-pseidokods" class="slide level2">
<h2><lo-summary/> Labā sufiksa tabulas pseidokods</h2>
<table class="pseudocode">
<tr>
<th colspan="2">
<span class="smallcaps">Good_Suffix_Table</span>(<span class="math inline">\(P\)</span>)
</th>
</tr>
<tr>
<td>
1
</td>
<td>
<span class="math inline">\(\pi =\)</span><span class="smallcaps">Compute_Prefix_Function</span>(<span class="math inline">\(P\)</span>)
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<span class="math inline">\(P&#39; = \mathit{reverse}(P)\)</span>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<span class="math inline">\(\pi&#39; =\)</span><span class="smallcaps">Compute_Prefix_Function</span>(<span class="math inline">\(P&#39;\)</span>)
</td>
</tr>
<tr>
<td>
4
</td>
<td>
<b>for</b> <span class="math inline">\(j=0\)</span> <b>to</b> <span class="math inline">\(m\)</span> <b>do</b>
</td>
</tr>
<tr>
<td>
5
</td>
<td class="ind1">
<span class="math inline">\(\gamma[j] = m - \pi[m]\)</span>
</td>
</tr>
<tr>
<td>
6
</td>
<td>
<b>for</b> <span class="math inline">\(l=1\)</span> <b>to</b> <span class="math inline">\(m\)</span> <b>do</b>
</td>
</tr>
<tr>
<td>
7
</td>
<td class="ind1">
<span class="math inline">\(j = m - \pi&#39;[l]\)</span>
</td>
</tr>
<tr>
<td>
8
</td>
<td class="ind1">
<span class="math inline">\(\gamma[j] = \max(\gamma[j], l - \pi&#39;[l])\)</span>
</td>
</tr>
<tr>
<td>
9
</td>
<td>
<b>return</b> <span class="math inline">\(\gamma\)</span>
</td>
</tr>
</table>
<p>Šajā algoritmā <span class="smallcaps">Compute_Prefix_Function</span> ir funkcija, kas saņem virkni <span class="math inline">\(P\)</span>, izrēķina šai virknei atbilstošo Knuta-Morisa Prata algoritma prefiksu funkciju <span class="math inline">\(\pi[j]\)</span> un atgriež šo masīvu.</p>
</section></section>
<section id="section-2" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span style="color:darkgreen"><strong>(3) BM algoritma piemēri</strong></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup></section>
<section id="bm-algoritma-piemērs---1" class="title-slide slide level1"><h1><lo-sample/> BM algoritma piemērs - 1</h1><hgroup style="font-size:80%">
<table>
<tr>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{d}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{b}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{b}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{c}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{b}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{b}\)</span>
</th>
</tr>
<tr>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{a}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{b}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{\mathtt{c}}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{a}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{b}\)</span>
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{a}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{b}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{c}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{a}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{\mathtt{b}}\)</span>
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
<span class="math inline">\(\color{#080}{\mathtt{a}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#080}{\mathtt{b}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#080}{\mathtt{c}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#080}{\mathtt{a}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#080}{\mathtt{b}}\)</span>
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
 
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{a}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#CCC}{\mathtt{b}}\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{\mathtt{c}}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{a}\)</span>
</td>
<td>
<span class="math inline">\(\mathtt{b}\)</span>
</td>
</tr>
</table>
<p>Apskatīsim <span class="math inline">\(T = \mathtt{daababcabaab}\)</span> un <span class="math inline">\(P = \mathtt{abcab}\)</span>.<br />
Meklējam no labās puses uz kreiso: Katra rindiņa attēlo vienu mēģinājumu atrast apakšstringu. Ar <red>sarkanu</red> apzīmē burtu, kurā simbols no <span class="math inline">\(P\)</span> nav sakritis ar atbilstošo simbolu no <span class="math inline">\(T\)</span>.</p>
</hgroup>
<hgroup style="font-size:70%">
<ol type="1">
<li>Pirmajā mēģinājumā sakrita <span class="math inline">\(P[4]\)</span> un <span class="math inline">\(P[3]\)</span>, bet ne <span class="math inline">\(P[2]\)</span>. Tad pavirzāmies <span class="math inline">\(3\)</span> simbolus uz priekšu (saskaņā ar „labā sufiksa tabulu”).</li>
<li>skatāmies vai <span class="math inline">\(P[0]\ldots{}P[4]\)</span> sakrīt ar <span class="math inline">\(T[3]\ldots{}[7]\)</span>. Nesakritība ir jau <span class="math inline">\(P[4]\)</span> un tad saskaņā ar „sliktā simbola tabulu” pavirzāmies pa <span class="math inline">\(2\)</span> simboliem, lai atrastais “c” sakristu ar pirmo iespējamo “c”, kas ir apakšvirknē <span class="math inline">\(P\)</span> (pirmo – no beigām).</li>
<li>Trešajā mēģinājumā sakrīt viss apakšstrings. Ja nepieciešams atrast visas vietas tekstā <span class="math inline">\(T\)</span>, kur ir apakšvirkne <span class="math inline">\(P\)</span>, tad saskaņā ar <span class="math inline">\(\gamma[0]\)</span> pārvietojamies <span class="math inline">\(3\)</span> simbolus uz priekšu un mēģinām vēl.</li>
<li>Pēdējais mēģinājums ir neveiksmīgs un tad esam sasnieguši teksta beigas.</li>
</ol>
</hgroup></section>
<section id="section-3" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span style="color:darkgreen"><strong>(4) Rekursīvu algoritmu sarežģītība</strong></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup></section>
<section id="astes-rekursija" class="title-slide slide level1"><h1><lo-theory/> “Astes rekursija”</h1><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> factorial(n): </a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">else</span>: <span class="cf">return</span> n<span class="op">*</span>factorial(n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="bu">print</span>(factorial(<span class="dv">100</span>))</a></code></pre></div>
<ul>
<li>Vai funkcija pareizi rēķina faktoriālus pie <span class="math inline">\(n \geq 0\)</span>?</li>
<li>Kas strādā labāk - rekursīva faktoriāla izteiksme vai reizināšana ar “for” ciklu?</li>
</ul></section>
<section><section id="fibonači-virkne" class="title-slide slide level1"><h1><lo-sample/> Fibonači virkne</h1><div style="font-size:80%">
<p>Virkni <span class="math inline">\(F(n)\)</span> definē šādi: <span class="math inline">\(F_0 = 0\)</span>, <span class="math inline">\(F_1 = 1\)</span> un <span class="math display">\[F_{n+2} = F_n + F_{n+1}.\]</span></p>
<table>
<tr>
<th>
<span class="math inline">\(n\)</span>
</th>
<th>
<span class="math inline">\(0\)</span>
</th>
<th>
<span class="math inline">\(1\)</span>
</th>
<th>
<span class="math inline">\(2\)</span>
</th>
<th>
<span class="math inline">\(3\)</span>
</th>
<th>
<span class="math inline">\(4\)</span>
</th>
<th>
<span class="math inline">\(5\)</span>
</th>
<th>
<span class="math inline">\(6\)</span>
</th>
<th>
<span class="math inline">\(7\)</span>
</th>
<th>
<span class="math inline">\(8\)</span>
</th>
<th>
<span class="math inline">\(9\)</span>
</th>
<th>
<span class="math inline">\(10\)</span>
</th>
</tr>
<tr>
<th>
<span class="math inline">\(F(n)\)</span>
</th>
<td>
<span class="math inline">\(0\)</span>
</td>
<td>
<span class="math inline">\(1\)</span>
</td>
<td>
<span class="math inline">\(1\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(5\)</span>
</td>
<td>
<span class="math inline">\(8\)</span>
</td>
<td>
<span class="math inline">\(13\)</span>
</td>
<td>
<span class="math inline">\(21\)</span>
</td>
<td>
<span class="math inline">\(34\)</span>
</td>
<td>
<span class="math inline">\(55\)</span>
</td>
</tr>
</table>
<p>Ar indukciju var pamatot, ka visiem <span class="math inline">\(n \geq 1\)</span>: <span class="math display">\[F_n = \frac{1}{\sqrt{5}}\left[ \left( \frac{1 + \sqrt{5}}{2}  \right)^n -
\left( \frac{1 - \sqrt{5}}{2} \right)^n \right]\;\;\text{un arī}\]</span></p>
<p><span class="math display">\[\left( \begin{array}{cc}
1 &amp; 1\\
1 &amp; 0 \end{array} \right)^n = 
\left( \begin{array}{cc}
F_{n+1} &amp; F_{n}\\
F_{n} &amp; F_{n-1} \end{array} \right).\]</span></p>
</div></section><section id="rekursīva-fibonači-funkcija" class="slide level2">
<h2><lo-sample/> Rekursīva Fibonači funkcija</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> fib(n):</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="cf">else</span>: <span class="cf">return</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">    </a>
<a class="sourceLine" id="cb2-6" title="6"><span class="bu">print</span>(fib(<span class="dv">40</span>))</a></code></pre></div>
<ul>
<li>Vai funkcija rēķina Fibonači skaitļus pie <span class="math inline">\(n \geq 0\)</span>?</li>
<li>Kāda ir šīs funkcijas laika sarežģītība?</li>
</ul>
</section><section id="fibonači-funkcija-ar-atmiņu" class="slide level2">
<h2><lo-theory/> Fibonači funkcija ar atmiņu</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">memo <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">def</span> fibonacci(n):</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">while</span> <span class="bu">len</span>(memo) <span class="op">&lt;</span> n<span class="op">+</span><span class="dv">1</span>:</a>
<a class="sourceLine" id="cb3-4" title="4">        memo.append(<span class="dv">0</span>)  </a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb3-6" title="6">        <span class="cf">return</span> n  </a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="cf">elif</span> memo[n<span class="dv">-1</span>] <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb3-8" title="8">        memo[n<span class="dv">-1</span>] <span class="op">=</span> fibonacci(n<span class="dv">-1</span>)                </a>
<a class="sourceLine" id="cb3-9" title="9">    memo[n] <span class="op">=</span> memo[n<span class="dv">-2</span>] <span class="op">+</span> memo[n<span class="dv">-1</span>]</a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="cf">return</span> memo[n]</a></code></pre></div>
<ul>
<li>Astes rekursiju var arī pārrakstīt ar “for” ciklu.</li>
<li>Sk. <a href="https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/">iedvesmas avotu</a></li>
</ul>
</section></section>
<section><section id="section-4" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span style="color:darkgreen"><strong>(5) Dinamiskā programmēšana</strong></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup></section><section id="memoizācija-un-dinamiskā-programmēšana" class="slide level2">
<h2><lo-summary/> Memoizācija un Dinamiskā programmēšana</h2>
<hgroup style="font-size:80%">
<p><strong>Definīcija:</strong> Par <blue><em>memoizāciju</em></blue> (<em>memoization</em>) sauc starpvērtību noglabāšanu (piemēram, vērtību tabulā). Ja to pašu starpvērtību algoritmam vajag vairākkārt, to nerēķina atkārtoti, bet izmanto kešoto vērtību no tabulas.<br />
Memoizācija ir atsevišķs gadījums <blue><em>kešošanai</em></blue> (<em>caching</em>) - šajā gadījumā nepastāv izvēle iztīrīt kešu.</p>
</hgroup>
<hgroup style="font-size:80%">
<p><strong>Definīcija:</strong> Par <blue><em>dinamisko programmēšanu</em></blue> (<em>dynamic programming</em>) sauc vispārīgu pieeju algoritmu (īpaši optimizācijas algoritmu) veidošanai. DP pieeja sastāv no šādiem lieliem soļiem:</p>
<ul>
<li>Sadala uzdevumu apakšuzdevumos.</li>
<li>Katram apakšuzdevumam piekārto vērtību.</li>
<li>Atrod sakarību starp apakšuzdevumu vērtībām.</li>
<li>Ciklā rēķina rekurento sakarību un piepilda memoizāciju tabulu.</li>
<li>Atrod memoizāciju tabulā sākotnējā uzdevuma atrisinājumu.</li>
</ul>
</hgroup>
</section></section>
<section id="daijkstras-īsāko-ceļu-algoritms" class="title-slide slide level1"><h1><lo-summary/> Daijkstras īsāko ceļu algoritms</h1><p><strong>Uzdevums:</strong> Dots orientēts grafs <span class="math inline">\(G(V,E)\)</span>, kura virsotņu kopa ir <span class="math inline">\(V\)</span>, šķautņu kopa ir <span class="math inline">\(E\)</span> un katrai šķautnei <span class="math inline">\((u,v) \in E\)</span> (kur <span class="math inline">\(u,v \in V\)</span> ir divas savienotas grafa virsotnes) ir pierakstīts nenegatīvs svars <span class="math inline">\(w(u,v)\)</span>: cik maksā nokļūšana no <span class="math inline">\(u\)</span> uz <span class="math inline">\(v\)</span> pa šo šķautni.<br />
Daikstras algoritms atrod “viena avota īsākos ceļus” grafā <span class="math inline">\(G\)</span>: Dotajai sākuma virsotnei <span class="math inline">\(s \in V\)</span> tas atrod pašus lētākos ceļus uz jebkuru citu virsotni šajā grafā.</p></section>
<section id="section-5" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span style="color:darkgreen"><strong>(6) Labošanas attālums</strong></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup></section>
<section><section id="labošanas-attālums" class="title-slide slide level1"><h1><lo-theory/> Labošanas attālums</h1><p>Dotas simbolu virknes <span class="math inline">\(A = A[0]\ldots{}A[m-1]\)</span> un <span class="math inline">\(B = B[0]\ldots{}B[n-1]\)</span>, kuru garumi ir attiecīgi <span class="math inline">\(m\)</span> un <span class="math inline">\(n\)</span>. Atļautas sekojošas operācijas jeb <blue><em>labojumi</em></blue> (<em>edits</em>):</p>
<ul>
<li>Viena simbola aizstāšana ar citu simbolu;</li>
<li>Jebkura viena simbola izdzēšana;</li>
<li>Jauna simbola iespraušana patvaļīgā vietā.</li>
</ul>
<p><strong>Definīcija:</strong> Par <blue><em>Levenšteina attālumu</em></blue> (<em>Levenshtein distance</em>, <em>editing distance</em>) <span class="math inline">\(M(A,B)\)</span> diviem vārdiem <span class="math inline">\(A=A[0]\ldots{}A[m-1]\)</span> un <span class="math inline">\(B=B[0]\ldots{}B[n-1]\)</span> sauc mazāko iespējamo labojumu skaitu, kas pārtaisa <span class="math inline">\(A\)</span> par <span class="math inline">\(B\)</span>.</p></section><section id="citi-labošanas-attāluma-varianti" class="slide level2">
<h2><lo-theory/> Citi labošanas attāluma varianti</h2>
<ul>
<li>Ja viena simbola aizstāšana ar citu ir divreiz dārgāka par iespraušanu un izdzēšanu?</li>
<li>Ja virkni <span class="math inline">\(A\)</span> jāpārveido par kādu <span class="math inline">\(B\)</span> apakšvirkni (nevis pašu <span class="math inline">\(B\)</span>)?</li>
<li>Ja labojuma izmaksas atkarīgas no dzēšamā/iespraužamā simbola?</li>
<li>Ja <span class="math inline">\(k\)</span> simbolu apakšvirkni var iespraust/izdzēst vienā gājienā ar izmaksu <span class="math inline">\(f(k)\)</span> (šeit <span class="math inline">\(f(k)&lt;k\)</span> jeb apakšvirknes iespraušana ir lētāka nekā <span class="math inline">\(k\)</span> burtu mainīšana pa vienam).</li>
</ul>
<p><strong>Motivācija:</strong> Uzdevums parādās, piemēram, bioinformātikā. Šādus uzdevumus sauc par <blue><em>aptuveno salīdzināšanu</em></blue> (<em>Sequence alignment</em>). Piemēram, cik mutāciju vajag, lai viena DNS virkne pārvērstos par otru virkni.</p>
</section><section id="levenšteina-attālums-ar-matricu-rekurencēm" class="slide level2">
<h2><lo-theory/> Levenšteina attālums ar matricu rekurencēm</h2>
<div style="font-size:70%">
<p>Doti vārdi <span class="math inline">\(A=A[0]\ldots{}A[m-1]\)</span> un <span class="math inline">\(B=B[0]\ldots{}B[n-1]\)</span>. Definējam <span class="math inline">\((m+1) \times (n+1)\)</span> izmēra matricu <span class="math inline">\(M[i,j]\)</span> ar šādām sakarībām</p>
<p><span class="math display">\[\begin{array}{l}
M[0,0]=0\\
M[i,0]=i,\;1 \leq i \leq m\\
M[0,j]=j,\;1 \leq j \leq n\\
M[i,j]=\min \left\{ \begin{array}{l}
M[i-1,j-1] + 0,\;\text{ja}\;A[i] = B[j]\\
M[i-1,j-1] + 1,\;\text{(burta aizstāšana)}\\
M[i,j-1] + 1,\;\text{(burta iespraušana)}\\
M[i-1,j] + 1,\;\text{(burta dzēšana)}
\end{array} \right. 
\end{array}\]</span></p>
<p>Ar indukciju var pamatot, ka šādi rēķinot <span class="math inline">\(M[i,j]\)</span> visiem <span class="math inline">\(i \in [1,m]\)</span> un <span class="math inline">\(j \in [1,n]\)</span>, matricas labajā apakšējā stūrī iegūsim <span class="math inline">\(M[m,n]\)</span>, kas būs Levenšteina attālums starp vārdiem <span class="math inline">\(A\)</span> un <span class="math inline">\(B\)</span>.</p>
</div>
<p>Sal. <a href="https://de.wikipedia.org/wiki/Levenshtein-Distanz">Editierdistantz</a></p>
</section><section id="labošanas-attāluma-pseidokods" class="slide level2">
<h2><lo-summary/> Labošanas attāluma pseidokods</h2>
<table class="pseudocode" style="font-size:70%">
<tr>
<th colspan="2">
<tt>Levenstein_Distance</tt>(<span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>)
</th>
</tr>
<tr>
<td>
1
</td>
<td>
<span class="math inline">\(m = A.\mathit{length}\)</span>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<span class="math inline">\(n = B.\mathit{length}\)</span>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<b>for</b> <span class="math inline">\(i = 0\)</span> <b>to</b> <span class="math inline">\(m\)</span>
</td>
</tr>
<tr>
<td>
4
</td>
<td class="ind1">
<span class="math inline">\(M[0,i] = 0\)</span>
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<b>for</b> <span class="math inline">\(j = 0\)</span> <b>to</b> <span class="math inline">\(n\)</span>
</td>
</tr>
<tr>
<td>
6
</td>
<td class="ind1">
<span class="math inline">\(M[j,0] = 0\)</span>
</td>
</tr>
<tr>
<td>
7
</td>
<td>
<b>for</b> <span class="math inline">\(i = 1\)</span> <b>to</b> <span class="math inline">\(m\)</span>
</td>
</tr>
<tr>
<td>
8
</td>
<td class="ind1">
<b>for</b> <span class="math inline">\(j = 1\)</span> <b>to</b> <span class="math inline">\(n\)</span>
</td>
</tr>
<tr>
<td>
9
</td>
<td class="ind2">
<b>if</b> <span class="math inline">\(A[i] == B[j]\)</span>
</td>
</tr>
<tr>
<td>
10
</td>
<td class="ind3">
<span class="math inline">\(M[i,j] = M[i-1,j-1]\)</span>
</td>
</tr>
<tr>
<td>
11
</td>
<td class="ind2">
<b>else</b> <span class="math inline">\(M[i, j] = \min (M[i-1, j]+1,\)</span>
</td>
</tr>
<tr>
<td>
 
</td>
<td class="ind4">
<span class="math inline">\(M[i, j-1]+1, M[i-1, j-1]+1)\)</span>
</td>
<tr>
<td>
12
</td>
<td>
<b>return</b> <span class="math inline">\(M[m,n]\)</span>
</td>
</tr>
</table>
</section></section>
<section><section id="dinamiskās-programmēšanas-piemērs" class="title-slide slide level1"><h1><lo-sample/> Dinamiskās programmēšanas piemērs</h1><div style="font-size:70%">

<p>Atrast Levenšteina attālumu starp <span class="math inline">\(A=\mathtt{tcat}\)</span> un <span class="math inline">\(B=\mathtt{atcaca}\)</span>. Aizpildām <span class="math inline">\(5 \times 7\)</span> matricu:</p>
<table>
<tr>
<th>
 
</th>
<th>
<span class="math inline">\(\mathtt{-}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{t}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{c}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{c}\)</span>
</th>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
</tr>
<tr>
<th>
<span class="math inline">\(\mathtt{-}\)</span>
</th>
<td>
<span class="math inline">\(\color{#F00}{0}\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{1}\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(4\)</span>
</td>
<td>
<span class="math inline">\(5\)</span>
</td>
<td>
<span class="math inline">\(6\)</span>
</td>
</tr>
<tr>
<th>
<span class="math inline">\(\mathtt{t}\)</span>
</th>
<td>
<span class="math inline">\(1\)</span>
</td>
<td>
<span class="math inline">\(1\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{1}\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(4\)</span>
</td>
<td>
<span class="math inline">\(5\)</span>
</td>
</tr>
<tr>
<th>
<span class="math inline">\(\mathtt{c}\)</span>
</th>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{1}\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(4\)</span>
</td>
</tr>
<tr>
<th>
<span class="math inline">\(\mathtt{a}\)</span>
</th>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{1}\)</span>
</td>
<td>
<span class="math inline">\(4\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
</tr>
<tr>
<th>
<span class="math inline">\(\mathtt{t}\)</span>
</th>
<td>
<span class="math inline">\(4\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(3\)</span>
</td>
<td>
<span class="math inline">\(2\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{2}\)</span>
</td>
<td>
<span class="math inline">\(\color{#F00}{3}\)</span>
</td>
</tr>
</table>
<p>Pirmkārt, no šīs tabulas uzzinām, ka minimālais operāciju skaits ir <span class="math inline">\(3\)</span>.<br />
Otrkārt, no tās var atjaunot optimālo labojumu virkni. To dara no beigām.</p></section><section id="īsākā-labojumu-secība" class="slide level2">
<h2><lo-sample/> Īsākā labojumu secība</h2>
<hgroup>
<p>TODO</p>
</hgroup>
<hgroup style="font-size:70%">
<p>No Dinamiskās programmēšanas tabuliņas atjauno labojumu secību:</p>
<ol type="1">
<li><span class="math inline">\(M[4,6]=3\)</span> iegūts, pieskaitot <span class="math inline">\(1\)</span> pie <span class="math inline">\(M[4,5]=2\)</span>.</li>
<li><span class="math inline">\(M[4,5]=2\)</span> iegūts, pieskaitot <span class="math inline">\(1\)</span> pie <span class="math inline">\(M[3,4] = 1\)</span>.</li>
<li><span class="math inline">\(M[3,4]=1\)</span> iegūts no <span class="math inline">\(M[2,3]=1\)</span>, iegūts no <span class="math inline">\(M[1,2]=1\)</span>, iegūts no <span class="math inline">\(M[0,1]=1\)</span>.</li>
</ol>
<p>Tas nozīmē, ka <span class="math inline">\(\mathtt{atcaca}\)</span> no <span class="math inline">\(\mathtt{tcat}\)</span> var iegūt šādi: <span class="math display">\[\mathtt{tcat} \rightarrow \mathtt{atcat} \rightarrow \mathtt{atcac} \rightarrow \mathtt{atcaca}.\]</span></p>
</hgroup>
</section></section>
<section id="minimālie-ceļi-grafā" class="title-slide slide level1"><h1><lo-summary/> Minimālie ceļi grafā</h1><hgroup>
<figure>
<img data-src="graph-distances.png" alt="Graph Distances" /><figcaption>Graph Distances</figcaption>
</figure>
</hgroup>
<hgroup style="font-size:70%">
<p>Grafa virsotnes <span class="math inline">\((i, j)\)</span> atbilst tabulas elementiem <span class="math inline">\(M[i, j]\)</span>.</p>
<ul>
<li>Virsotņu pāri, kas sastāv no <span class="math inline">\((i,j-1)\)</span> un <span class="math inline">\((i, j)\)</span>, vai no <span class="math inline">\((i-1,j)\)</span> un <span class="math inline">\((i,j)\)</span>, savienoti ar šķautni garumā <span class="math inline">\(1\)</span>.</li>
<li>Virsotņu pāri, kas sastāv no <span class="math inline">\((i-1,j-1)\)</span> un <span class="math inline">\((i,j)\)</span>, savienoti ar šķautni garumā <span class="math inline">\(0\)</span> (zīmējumā – pārtraukta līnija), ja <span class="math inline">\(A[i] = B[j]\)</span> un šķautni garumā <span class="math inline">\(1\)</span> citos gadījumos.</li>
</ul>
<p><span class="math inline">\(M[m,n]\)</span> ir īsākais ceļš no <span class="math inline">\((0,0)\)</span> uz <span class="math inline">\((m,n)\)</span>. To izrēķina ar Daikstras algoritmu īsākā ceļa atrašanai. Tam vajadzīgi <span class="math inline">\(O(n \cdot D)\)</span> soļi, kur <span class="math inline">\(D\)</span> - minimālais labojumu skaits. Ja <span class="math inline">\(D &lt;&lt; m,n\)</span> (virknes ir ļoti līdzīgas), tad tas ir labāk nekā <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</hgroup></section>
<section><section id="daikstras-algoritms" class="title-slide slide level1"><h1><lo-summary/> Daikstras algoritms</h1><p>Daikstras algoritms atrod īsākos ceļus no vienas virsotnes grafā uz katru no pārējām virsotnēm. Šajā konkrētajā gadījumā Daikstras algoritms ir vienkāršāks nekā vispārējā gadījumā:</p>
<ol type="1">
<li><span class="math inline">\(i=0\)</span>;</li>
<li>Izveido sarakstu <span class="math inline">\(S_i\)</span> ar visām virsotnēm attālumā <span class="math inline">\(i\)</span> no <span class="math inline">\((0;0)\)</span>. Palielina <span class="math inline">\(i\)</span> (<span class="math inline">\(i = i+1\)</span>).</li>
<li>Soli Nr.2 atkārto līdzkamēr <span class="math inline">\((m,n) \in S_i\)</span>.</li>
</ol></section><section id="saraksta-s_0-izveide" class="slide level2">
<h2><lo-summary/> Saraksta S_0 izveide</h2>
<ol type="1">
<li><span class="math inline">\(i = 0\)</span></li>
<li>Pievieno <span class="math inline">\((i,i)\)</span> sarakstam <span class="math inline">\(S_0\)</span>, <span class="math inline">\(i = i+1\)</span> līdz brīdim kad <span class="math inline">\(A[i] \neq B[i]\)</span>.</li>
</ol>
</section><section id="saraksta-s_i-izveide-i0" class="slide level2">
<h2><lo-summary/> Saraksta S_i izveide (i&gt;0)</h2>
<div style="font-size:70%">
<p>Priekš katra iepriekšējā saraksta <span class="math inline">\(S_{i-1}\)</span> elementa <span class="math inline">\((j, k)\)</span>:</p>
<ol type="1">
<li>Ja <span class="math inline">\((j+1,k)\)</span> nav nevienā no sarakstiem <span class="math inline">\(S_0, S_1, \ldots, S_{i-1}\)</span>, tad:
<ul>
<li>Pievieno <span class="math inline">\((j+1, k)\)</span> sarakstam <span class="math inline">\(S_i\)</span>.</li>
<li>Katram <span class="math inline">\(r&gt;0\)</span>, kuram apakšvirkne <span class="math inline">\(A[j+2]\ldots{}A[j+r+1]\)</span> sakrīt ar <span class="math inline">\(B[k+1]\ldots{}B[k+r]\)</span>, pievieno <span class="math inline">\((j+r+1, k+r)\)</span> sarakstam <span class="math inline">\(S_i\)</span>.</li>
</ul></li>
<li>Ja <span class="math inline">\((j,k+1)\)</span> nav nevienā no sarakstiem <span class="math inline">\(S_0, S_1, \ldots, S_{i-1}\)</span>, tad:
<ul>
<li>Pievieno <span class="math inline">\((j, k+1)\)</span> sarakstam <span class="math inline">\(S_i\)</span>.</li>
<li>Katram <span class="math inline">\(r&gt;0\)</span>, kuram apakšvirkne <span class="math inline">\(A[j+1]\ldots{}A[j+r]\)</span> sakrīt ar B[k+2]{}B[k+r+1]$, pievieno <span class="math inline">\((j+r,k+r+1)\)</span> sarakstam <span class="math inline">\(S_i\)</span>.</li>
</ul></li>
<li>Ja <span class="math inline">\((j+1, k+1)\)</span> nav nevienā no sarakstiem <span class="math inline">\(S_0, S_1, \ldots, S_{i-1}\)</span>, tad:
<ul>
<li>Pievieno <span class="math inline">\((j+1, k+1)\)</span> sarakstam <span class="math inline">\(S_i\)</span>.</li>
<li>Katram <span class="math inline">\(r&gt;0\)</span>, kuram apakšvirkne <span class="math inline">\(A[j+2]\ldots{}A[j+r+1]\)</span> sakrīt ar <span class="math inline">\(B[k+2]\ldots{}B[k+r+1]\)</span>, pievieno <span class="math inline">\((j+r+1, k+r+1)\)</span> sarakstam <span class="math inline">\(S_i\)</span>.</li>
</ul></li>
</ol>
</div>
</section></section>
<section id="section-6" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span style="color:darkgreen"><strong>(7) (P) Regulāru izteiksmju meklēšana</strong></span><br />
<span>(8) <a href="#/section7">Kopsavilkums</a></span></p>
</hgroup></section>
<section id="section-7" class="title-slide slide level1"><h1> </h1><hgroup>
<h1 style="font-size:28pt">
Lietišķie algoritmi
</h1>
<p><blue>Virkņu meklēšana - 2</blue></p>
</hgroup>
<hgroup style="font-size:90%">
<p><span>(1) <a href="#/section">Ievads</a></span><br />
<span>(2) <a href="#/section-1">Bojera-Mūra algoritms</a></span><br />
<span>(3) <a href="#/section-2">BM algoritma piemēri</a></span><br />
<span>(4) <a href="#/section-3">Rekursīvu algoritmu sarežģītība</a></span><br />
<span>(5) <a href="#/section-4">Dinamiskā programmēšana</a></span><br />
<span>(6) <a href="#/section-5">Labošanas attālums</a></span><br />
<span>(7) <a href="#/section-6">(P) Regulāru izteiksmju meklēšana</a></span><br />
<span style="color:darkgreen"><strong>(8) Kopsavilkums</strong></span></p>
</hgroup></section>
    </div>
  </div>

  <script src="../../reveal.js/lib/js/head.min.js"></script>
  <script src="../../reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: '../../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: '../../reveal.js/plugin/math/math.js', async: true },
          { src: '../../reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
