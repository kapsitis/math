\documentclass[11pt]{article}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{changepage}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{gensymb}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{tabularx}
\usepackage{lipsum}
\usepackage{hyperref}

\oddsidemargin 0.0in
\evensidemargin 0.0in
\textwidth 6.27in
\headheight 1.0in
\topmargin -0.1in
\headheight 0.0in
\headsep 0.0in
\textheight 9.50in

%\setlength\parindent{0pt}

\newenvironment{myenv}{\begin{adjustwidth}{0.4in}{0.4in}}{\end{adjustwidth}}
\renewcommand{\abstractname}{Anotācija}
\renewcommand\refname{Atsauces}



\newcounter{alphnum}
\newenvironment{alphlist}{\begin{list}{(\Alph{alphnum})}{\usecounter{alphnum}\setlength{\leftmargin}{2.5em}} \rm}{\end{list}}


%16.3-6
% 
% http://www.ccs.neu.edu/home/jaa/CS6800.11F/Homeworks/HW05.pdf


\makeatletter
\let\saved@bibitem\@bibitem
\makeatother

\usepackage{bibentry}
%\usepackage{hyperref}


\begin{document}

\thispagestyle{empty}

{\Large Lietišķie algoritmi \textendash{} 1. mājas darbs: Atrisinājumi}


{\footnotesize
\noindent
{\bf 1.uzdevums: Aritmētiskais kods.}
Dota ziņojumu kopa $S = \{ A,B,C,D \}$ ar attiecīgajām varbūtībām 
$\{ 0.2, 0.5, 0.2, 0.1 \}$.
\begin{enumerate}[(a)]
\item Parādīt, kā iegūt aritmētisko kodu $6$ ziņojumu virknei {\tt CBAABD} -- uzkonstruēt
tai atbilstošo intervālu $[l_6;l_6+s_6) \in [0;1]$ un atrast 
īsāko bitu virkni $d_1d_2\ldots{}d_{\ell}$ (visi $d_k \in \{ 0,1 \}$, 
kur pierakstot binārā pieraksta daļskaitlim $D = 0.d_1d_2\ldots{}d_{\ell}\ldots$ 
galā jebkuru turpinājumu ar cipariem $0$ vai $1$, iegūtais skaitlis $d+\varepsilon$ pieder
intervālam $[l_6;l_6+s_6)$.
\item Noteikt, kādu ziņojumu virkni alfabētā $S$ kodē skaitlis 
$D'' = 0.0011101011_2$.
\end{enumerate}
}

\noindent
{\bf (a)} Sākotnējais intervāls $[l_0;l_0+s_0] = [0;1]$. Uzrakstām tālākos 
sešus intervālus: 
$$\begin{array}{rcl}
I_1 & = & [0.70000,0.90000)\\
I_2 & = & [0.74000,0.84000)\\
I_3 & = & [0.74000,0.76000)\\
I_4 & = & [0.74000,0.74400)\\
I_5 & = & [0.74080,0.74280)\\
I_6 & = & [0.74260,0.74280)
\end{array}$$

Pēdējo intervālu $I_6$ kodē bitu virkne {\tt 1011111000100}, jo 
skaitlis ${\displaystyle 0.1011111000100_2 = \frac{6084}{2^{13}}}$
un 
$$\left[ \frac{6084}{2^{13}}}; \frac{6085}{2^{13}} \right] \subseteq [0.74260,0.74280).$$
Kodiem garumā $13$ citus skaitļus (izņemot jau atrastos $6064/8192$ un $6065/8192$) izmantot nevar: 
intervāls pilnībā neietilps $I_6$. 

{\em Piezīme:} Ja esat ņēmuši kodu, kurš ir $14$ vienības garš vai garāku, tad 
būs arī citi atrisinājumi. Tos neuzskatām par nepareiziem, ja vien 
Jūsu kodam atbilstošais intervāls pilnībā ietilpst intervālā $I_6$. 
Praksē lietojamie aritmētiskie kodi vai nu pievieno ziņojumu 
alfabētam EOF (faila beigu) ziņojumu vai nu arī kaut kur 
iekodē ziņojumu virknes garumu, lai 
atkodētājs zinātu, kur apstāties. 

Īpašs "pseido EOF" simbols mēdz būt aktuāls pat Hafmana koda vingrinājumos. 
Atšķirībā no bināriem skaitļiem, Hafmana prefiksu kodu virknē it kā ir redzams, kur 
vajag apstāties, bet praksē tas bieži nenostrādā, jo failam jāsatur vesels skaits baitu; 
pēc visu Hafmana kodavārdu izrakstīšanas var gadīties daži lieki biti, kurus negribam atkodēt. 
Plašāku diskusiju par "pseido EOF" sk. Stenfordas universitātes uzdotajā programmēšanas mājasdarbā: 
\url{https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1172/assn/huffman.html}. 


\noindent
{\bf (b)} Sākam ar intevālu 
$$[0.0011101011_2;0.0011101100_2) = [235/1024;236/1024) \approx [0.2294922; 0.2304688).$$



{\footnotesize 
\vspace{10ex}
\noindent
{\bf 2.uzdevums: Lempela-Ziva algoritms.}
\begin{enumerate}[(a)]
\item 
Ar LZ78 metodi nokodēt tekstu “abracadabra, abracadabra”.
\item Atkodēt ar LZ78 metodi nokodētu tekstu $a,b,c,d,2,5,a,6$, kur
$a$, $b$ un $c$ apzīmē atbilstošos burtus, bet skaitļi – vārdnīcas virkņu
numurus.
\item
Nokodēt (a) punkta tekstu “abracadabra, abracadabra” 
ar LZ77 metodi, kā logu lietojot visu nokodēto/atkodēto tekstu.
\end{enumerate}
}

\noindent
{\bf (a)} 





{\footnotesize
\vspace{10ex}
\noindent
{\bf 3.uzdevums: Berouza-Vīlera transformācija.}
\begin{enumerate}[(a)]
\item 
Kāds ir rezultāts (transformētā simbolu virkne un sākotnējās virknes pozīcija), 
lietojot Berouza-Vīlera transformāciju 
$14$ simbolu virknei {\tt alusariirasula}?
\item Kāds ir iepriekšējā piemērā iegūtās transformētās simbolu virknes pieraksts,
izmantojot Move-to-Front kodēšanu?
\item Pēc BW transformācijas pielietošanas tika iegūta simbolu virkne 
{\tt mmmrvvauuuiibbbri}. Kāda bija simbolu virkne pirms 
transformācijas (ņemot 4.\ virkni
no atjaunotās tabulas)?
\end{enumerate}
}


\noindent
{\bf (a)} Ja lietojam to Berouza-Vīlera transformāciju, kāda tā aprakstīta 
Vikipēdijā: \url{https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform} 
\textendash piemērā ar vārdu {\tt \^{}BANANA|}, tad 
izrakstām visas $14$ cikliskās permutācijas vārdam {\tt alusariirasula}
($0,1,2,\ldots,13$ burtus no šī vārda beigām pārceļam uz tā sākumu). Pēc tam 
šīs permutācijas (rindiņas zemāk attēlotajā tabulā) sakārtojam leksikogrāfiski: 
vienkārši sakot, pēc alfabēta: Vispirms izrakstām visas permutācijas, kam
pirmais burts ir "a" (tās sašķiro pēc 2.burta; ja arī tas sakrīt, pēc 3.burta, utt.). 

Pēc tam ievērojam, ka pēdējā tabulas kolonnā rakstīts  {\tt lasrriuaiauasl}. 
Mūsu sākotnējās virknes {\tt alusariirasula} indekss ir $1$ (šī 
virkne redzama tabulas 2.rindiņā), bet indeksus sāk
numurēt, sākot no $0$: 2.rindiņas indekss tāpēc ir $1$. 

\begin{verbatim}
aalusariirasul
alusariirasula
ariirasulaalus
asulaalusariir
iirasulaalusar
irasulaalusari
laalusariirasu
lusariirasulaa
rasulaalusarii
riirasulaalusa
sariirasulaalu
sulaalusariira
ulaalusariiras
usariirasulaal
\end{verbatim}

\noindent
{\bf (b)} Kāds kods rodas no Move-to-Front, ja to lieto 
virknei {\tt lasrriuaiauasl}, kur alfabētiskais
sakārtojums ir $\mathtt{a}<\mathtt{i}<\mathtt{l}<\mathtt{r}<\mathtt{s}<\mathtt{u}$, kur burtu indeksus sāk skaitīt, 
sākot no 0.indeksa?

\noindent
Rakstām tabulu, kurai augšējā rindiņā ir kodējamais vārds, bet
alfabētus rakstām vertikāli uz leju:\\
\begin{tabular}{c|cccccccccccccc}
Alfabēts$\downarrow$ & l & a & s & r & r & i & u & a & i & a & u & a & s & l \\ \hline
a                    & l & a & s & r & r & i & u & a & i & a & u & a & s & l \\ 
i                    & a & l & a & s & s & r & i & u & a & i & a & u & a & s \\ 
l                    & i & i & l & a & a & s & r & i & u & u & i & i & u & a \\ 
r                    & r & r & i & l & l & a & s & r & r & r & r & r & i & u \\ 
s                    & s & s & r & i & i & l & a & s & s & s & s & s & r & i \\ 
u                    & u & u & u & u & u & u & l & l & l & l & l & l & l & r \\ \hline
Izeja:               & 2 & 1 & 4 & 4 & 0 & 4 & 5 & 4 & 2 & 1 & 2 & 1 & 4 & 6 
\end{tabular}


\noindent
{\bf (a) un (b) citam Berouza-Vīlera transformācijas variantam:}\\
Ja izmantojam Guy E.Blelloch grāmatu "Introduction to Data Compression", tad
Berouza-Vīlera transformāciju iegūst, sakārtojot cikliskās permutācijas
leksikogrāfiski pēc priekšpēdējā burta, ja sakrīt, tad pēc priekšpriešpēdējā, utt. 
Transformācijas rezultāts arī šajā gadījumā ir pēdējā kolonna. 

\begin{verbatim}
usariirasulaal
lusariirasulaa
ulaalusariiras
iirasulaalusar
asulaalusariir
rasulaalusarii
sariirasulaalu
alusariirasula
irasulaalusari
sulaalusariira
laalusariirasu
riirasulaalusa
aalusariirasul
ariirasulaalus
\end{verbatim}

Berouza-Vīlera transformācijas rezultāts ir pēdējā kolonna: {\tt lasrriuaiauals}. 
Tas ir cits vārds nekā {\tt lasrriuaiauasl} (pēdējie $2$ burti ir pretējā secībā). 
Arī Move-to-Front kods izskatās citādi: 
$$214404542121\color{#F00}{66}\;\;\text{nevis}\;\;214404542121\color{#F00}{46}$$
kā iepriekšējā variantā.





{\footnotesize
\vspace{10ex}
\noindent
{\bf 4.uzdevums: I-iespēja (atzīmei 10).} 
Pieņemsim, ka ziņojumu kopai $S = \{ x_1, x_2, \ldots, x_n \}$ ar 
izveidots optimāls prefiksu kodējums. Šis kodējums jāpārraida,
izmantojot minimālu bitu skaitu.\\
Pierādīt vai apgāzt šādu 
apgalvojumu: Jebkuru optimālu prefiksu 
kodējumu šai $n$ ziņojumu kopai var nosūtīt, izmantojot ne vairāk kā 
${\displaystyle 2n - 1 + n \left\lceil log_2 n \right\rceil}$ bitus. 
Šeit $\lceil x \rceil$ apzīmē noapaļošanu uz augšu jeb 
mazāko veselo skaitli, kas nav mazāks par $x$.
Piemēram $\lceil 17 \rceil = 17$ un $\lceil 3.14 \rceil = 4$.\\
{\em Ieteikums.} Izmantojot $2n-1$ bitus, var attēlot kodējumu koka 
virsotņu apstaigāšanas secību.
}

Pamatosim, ka prefiksu koku var nosūtīt, izmantojot ne vairāk kā
${\displaystyle 2n - 1 + n \left\lceil log_2 n \right\rceil}$ bitus.\\

Tad, ja būtu jānosūta vienkārši $n$ alfabēta simbolu permutācija (viens no $n!$ 
iespējamajiem šo ziņojumu izkārtojumiem, kurā katrs ziņojums parādās tieši vienu reizi), 
tad pietiktu ar $n \left\lceil log_2 n \right\rceil$ bitiem. Teiksim, 
$3$ simbolu permutācijai (kādai no virknēm $\mathtt{ABC}$, 
$\mathtt{ACB}$, $\mathtt{BAC}$, $\mathtt{BCA}$, $\mathtt{CAB}$ vai $\mathtt{CBA}$)
iztērējas $3 \cdot 2 = 6$ biti, jo katru no trim burtiem var uzrakstīt 
ar $2$ bitu virknīti. 

Tomēr jāatceras, ka mūsu mērķis ir nosūtīt nevis simbolu permutāciju, bet 
bināru koku, kurā šie simboli parādās kā "koka lapas" (balti aplīši zīmējumā). 

\begin{center}
\includegraphics[width=3in]{prefix-trees.png}\\
{\em Zīmējums: 2 prefiksu koki ziņojumu alfabētam $S = \{ A,B,C\}$.}
\end{center}

Lai šos kokus varētu atšķirt, var izmantot bināro operatoru $\ast$ un iekavas. Piemēram: 
$$\mathtt{(A}\ast\mathtt{(B}\ast\mathtt{C))}\;\;\text{un}\;\;\mathtt{((A}\ast\mathtt{B)}\ast\mathtt{C)}.$$
Šajā sintaksē simbols $\ast$ apzīmē divu bināru koku salīmēšanas darbību. 
Ir vēl taupīgāks pieraksta veids \textendash{} "apgrieztais poļu pieraksts"
({\em Reverse Polish Notation}), kurā 
$\mathtt{(A}\ast\mathtt{B)}$ aizstāj ar $\mathtt{AB}\ast$. Šajā sintaksē iekavas nav vajadzīgas, 
bet koku vienalga var atjaunot. 
Zīmējumā attēlotie prefiksu koki apgrieztajā poļu pierakstā būs šādi:\\
$\mathtt{ABC}\ast\ast$ un $\mathtt{AB}\ast\mathtt{C}\ast$

Vispārīgajā gadījumā, lai izveidotu šādu poļu pieraksta izteiksmi no $n$ simboliem, 
jāpieraksta šie simboli kaut kādā secībā un vēl $n-1$ zvaigznītes (binārā kokā 
ar $n$ lapām būs tieši $n-1$ iekšējas virsotnes \textendash{} lai no $n$ gabaliņiem izveidotu 
vienu koku, jālīmē kopā tieši $n-1$ reizes). 
Tā kā zvaigznīšu ir daudz, tās kodēsim vienkārši ar
bitu "1", bet katram ziņojumu alfabēta $S$ simbolam $x_i$ rakstīsim priekšā 
bitu "0".

{\bf Kodējuma piemēri:} Aplūkosim jau minēto
prefiksu koku {\tt (A$\ast$(B$\ast$C))}, kurš zīmējumā redzams pa kreisi: Tajā simbolu {\tt A} kodē ar 
virknīti "0", simbolu {\tt B} kodē ar "10", bet simbolu {\tt C} kodē ar "11".

Šī prefiksu koka apgrieztais poļu pieraksts ir $\mathtt{ABC}\ast\ast$. 
Tā kā saņēmējs vēl nezina, kā tiks kodēti ziņojumu alfabēta simboli,
tad kodējam tos vienkārši pēc kārtas ar vienāda garuma 
virknēm, kas visas sākas ar bitu "0". 
Simbola {\tt A} fiksētā garuma kods (prefiksu koka nosūtīšanai, 
nevis Hafmana kodēšanai ar mainīgā garuma kodu) būs 
virkne "000", {\tt B} kods būs virkne "001", 
{\tt C} kods būs "010". Tā kā $n=3$ nav divnieka pakāpe, tad virkne "011" paliek neizmantota. 

Pierakstu $\mathtt{ABC}\ast\ast$ tātad kodē virkne "000 001 010 1 1" (atkodēšanai atstarpes nevajag).\\
Savukārt citu bināro koku $\mathtt{AB}\ast\mathtt{C}\ast$, kas zīmējumā redzams pa labi, 
apzīmē virkne "000 001 1 010 1".

Patvaļīgam $n$ prefiksu koka kodējums sastāv no $n$ dažādiem ziņojuma simboliem \textendash{} katru 
no tiem kodē garumā $\left\lceil \log_2 n \right\rceil + 1$ biti. Vajadzīgas arī $n-1$ 
zvaigznītes. Katru no tiem kodē ar $1$ bitu. Kopīgais bitu skaits:
$$n\cdot\left( \left\lceil \log_2 n \right\rceil + 1 \right) + 
(n-1)\cdot{}1 = 2n-1 + n \left\lceil \log_2 n \right\rceil.$$
$\blacksquare$


\end{document}



