Week,Class,Id
1,topic,Use C++ and Object Orientation
1.1,task,Create HelloWorld style programs
1.1,description,"Explain the entry point of a program, how it handles input and output, some fundamental data types and their conversions. Introduce the basic steps for its compilation and linking. In the module we stick with the Visual Studio Code possibilities."
1.1,reading,CH01P01
1.1,reading,https://bit.ly/2Y53DtA (SOF:Khachaturyan2019) What is Plain Old Data (POD)
1.1,video,https://youtu.be/ajRj_LmDmjk (de:Franneck2016A) Erstes Progrde:de:amm (Hel
1.1,video,https://youtu.be/aLdRUnZeSAw (de:Franneck2016B) Datentypen & Variablen
1.1.1,task,Create a simple HelloWorld program
1.1.1,description,"Basic examples; whey they posess the main characteristics of an algorithm and how to run them in graphical IDEs (Visual Studio Code, etc). "
1.1.1.1,code,Test and run CLI programs using plaintext files for input and expected output (use Visual Studio Code).
1.1.1.2,code,Tag submittable files in version control and submit
1.1.1.3,code,Understand your assignment submission procedure and its messages
1.1.1.4,task,Write a program that also transforms input data
1.1.1.5,task,Use correct indentation and other basic coding conventions
1.1.1.6,task,Identify compiler and linker actions
1.1.1.7,task,Show the difference between the development environment and runtime environment.
1.1.2,task,Introduce fundamental types
1.1.2,description,
1.1.2.1,task,"Introduce integer  types (short, int, long)"
1.1.2.2,task,Introduce bool type
1.1.2.3,task,Define and use enum types
1.1.2.4,task,Introduce floating point types (float and double)
1.1.2.5,task,Introduce char type
1.1.2.6,task,Use std:string to manipulate strings
1.1.2.7,task,Convert between some fundamental types and strings
1.1.3,task,"Declare and use arrays, pointers, references and struct types"
1.1.3,description,
1.1.3.1,task,"Declare, define and initialize arrays of fundamental types"
1.1.3.2,task,Declare and use pointers to variables
1.1.3.3,task,Refer to arrays using pointers
1.1.3.4,task,Declare and use references
1.1.3.5,task,Use C-style struct types
1.1.4,task,"Use namespaces, typedefs, local and global variables"
1.1.4,description,Introduce the identifiers (fully qualified with namespaces or local); understand the scope of a variable.
1.1.4.1,task,Define variables inside a scope
1.1.4.2,task,Refer to namespaced variables (with or without “using” statement)
1.1.4.3,task,Use “typedef” to give shorthand names for new types
1.1.4.4,task,Understand C++ variable scoping rules
1.1.5,code,"Write code to identify integers, floats, strings that are periodic in some representation (decimal, binary or string)"
1.2,task,"Use expressions, control structures and functions in C++"
1.2,description,"This module introduces longer code fragments, builds larger expressions and assignments, explains the structures of loops, branching and switching statements."
1.2,reading,CH01P02
1.2,reading,CH01P03
1.2,reading,CH01P04
1.2,video,https://youtu.be/d9rMdfqIOek (de:Franneck2016C) Rechnen mit Variablen
1.2.1,task,Describe fundamental types in C++
1.2.1.1,task,Understand binary representation of integer and float types
1.2.1.2,task,List all number-related types in C++
1.2.1.3,task,Understand character and string related types and encodings
1.2.2,task,"Declare, define and initialize variables, know their scope"
1.2.2.1,task,Define variable pointers and references
1.2.2.2,task,Use namespaces explicitly or implicitly
1.2.2.3,task,Use literal values in variable initializations
1.2.3,task,Write conditional statements
1.2.3.1,task,Write if and if-else statements
1.2.3.2,task,Write chains of if statements
1.2.3.3,task,"Write switch statements, understand their performance implications"
1.2.4,task,Write loop statements. 
1.2.4.1,task,"Write pre-increment and postincrement loops, loop variable scope"
1.2.4.2,task,Write while statements
1.2.5,task,Declare enum datatypes
1.2.6,task,Declare struct datatypes
1.2.7,example,Output all subphrases (subsequences of words keeping the original order)
1.2.8,example,Write code to compute Fibonacci numbers in a regular recursive way (and then also using memoization).
1.3,task,Use C++ classes
1.3,description,"Explain the structure of class definition, public, private members, nested classes, constructors and destructors. "
1.3,reading,CH01P05
1.3,video,NA
1.3.1,task,Write simple class constructors and destructors
1.3.2,task,Understand class member instantiation
1.3.3,task,"Understand the visibility of class members by other members, clients and friends."
1.3.4,task,Introduce stl::string and a few other classes
1.4,task,Write multi-file programs in C++
1.4,description,Separate concerns go into different files and mutual function calls; we do not focus on OO concepts here.
1.4,reading,CH01P06
1.4,video,NA
1.4.1,task,Write C++ header files
1.4.1.1,task,Understand the use of macro commands; use macros to do definition guards.
1.4.1.2,task,Understand the process of compilation and linking.
1.4.2,task,Use various flavors of function calls
1.4.2.1,task,Define and call functions passing parameters by value
1.4.2.2,task,Define and call functions passing parameters by reference
1.4.2.3,task,Describe naming conventions and naming best practices in C++
1.4.2.4,task,Use plain recursion and tail recursion
1.4.2.5,task,Use mutual recursion
1.4.3,task,Use function pointers
1.4.4,example,"Find errors in projects using code inspection, testing, debugging and printouts."
1.4.5,code,Build and test a program from a command-line using a Makefile
1.5,task,Use Object Orientation concepts in C++
1.5,description,"The module explains the thinking behind keywords “public”, “private”, inheritance – and how this is typically used in writing algorithms and data-structure libraries."
1.5,reading,CH02P01;CH02P02;CH02P03
1.5,video,NA
1.5.1,task,Explain abstraction as an OO principle
1.5.2,task,Explain encapsulation as an OO principle; keywords public/private and friends
1.5.3,task,Explain inheritance as an OO principle; inheriting class contract
1.5.4,task,Explain polymorophism as an OO principle; keywords virtual/abstract
1.5.5,task,Define class hierarhies following the OO principles
1.5.6,task,Explain function overriding with inheritance
1.5.7,task,Explain abstract classes and virtual functions.
1.5.8,task,Define template functions and template classes. 
1.5.9,task,Define and use overloaded operators
1.6,task,Understand the C++ memory model
1.6,description,"Introduce handling the space or memory used by the algorithms during recursive function calls, memory allocation and deallocation. "
1.6,reading,CH14P01;CH14P02
1.6,video,NA
1.6.1,task,Use the automatic variables and heap variables
1.6.2,task,Understand the implications of memory allocation and deallocation
1.6.3,task,Use proper garbage collection practices and detect memory leaks
1.6.4,task,Use caching for speedup
1.6.5,task,Understand memory hierarchy
2,topic,Express algorithms through ADTs and data structure libraries
2.1,task,Analyze algorithms by counting data related operations
2.1,description,Here we analyze the algorithms at pseudocode level (making assumptions regarding the cost of data structure library calls). More detailed analysis that takes into account alternatives of implementing the data structures themselves is postponed to other modules.
2.1,reading,CH04P02
2.1,video,NA
2.1.1,task,Identify the key characteristics of an algorithm
2.1.2,task,"Determine function growth classes using O-notation, Ω-notation, Θ-notation."
2.1.3,task,Define the time complexity of an algorithm; make assumptions about the data structure manipulations
2.1.4,task,Define the space complexity of an algorithm
2.1.5,task,Describe the difference between feasible and infeasible algorithms
2.1.6,task,"Worst-case, expected and amortized complexity"
2.2,task,Define and implement functions for simple Abstract Data Types (ADT)
2.2,description,This module discusses just the simplest ADTs. Every data structure in this course can be described in this way; more ADTs will be defined in subsequent modules.
2.2,reading,CH06P01;CH06P02;CH06P03
2.2,video,NA
2.2.1,task,Define stack as an ADT
2.2.2,task,Define a deque as an ADT
2.2.3,task,Define a list as an ADT
2.2.4,task,Define a sequence as an ADT
2.2.5,task,Define a binary tree as an ADT
2.2.6,task,Define a map as an ADT
2.2.7,task,Understand how one ADT can have different implementations
2.2.7.1,task,Implement data structures in arrays
2.2.7.2,task,Implement data structures with pointers
2.2.7.3,task,Understand advantages of encapsulation and hiding implementation details
2.3,task,"Use STL to implement containers - vectors, stacks and maps"
2.3,description,"Some built-in data structure libraries and template classes are introduced; this is the preferred way for the vast majority of C++ code that is ever written. (Only rarely you need to look at the implementation “under the hood”, and this will become our focus later on.)"
2.3,reading,CH01P05
2.3,reading,https://bit.ly/2NBvNXh
2.3,video,NA
2.3.1,task,Indentify the main container classes typically implemented by data structure libraries
2.3.1.1,task,"Identify the key manipulations (initialize, sort, search, transform) on containers"
2.3.1.2,task,Identify the iterators and ways to visit each element in a container for custom processing
2.3.2,task,Understand representation invariants (rep invariants)
2.3.2.1,task,Understand the representational exposure
2.3.2.2,task,"Use defensive copying, proper get/set methods, verbal contract with client classes to avoid exposure"
2.3.3,task,"Use STL to initialize vectors, stacks and maps"
2.3.4,task,Use C++ constructs to iterate over data structures
2.4,task,Define OO design patterns in C++
2.4,description,"The module only lists those design patterns that are typically used with data structures. One can certainly write good code without using “Gang of Four” jargon, but it can explain the thinking behind some popular APIs and data structure libraries."
2.4,reading,CH02P01; CH05P03; CH07P03; CH09P01; CH11P04; CH13P03
2.4,video,NA
2.4.1,task,Describe the tradeoffs between top-down and bottom-up design
2.4.2,task,Define the singleton OO design pattern
2.4.3,task,Define the factory OO design pattern
2.4.4,task,Define the adapter OO design patern
2.4.5,task,Define the decorator OO design patern
2.4.6,task,Define the command OO design pattern
2.4.7,task,Define the composite OO design pattern
2.4.8,task,Define the memento OO design pattern
2.4.9,task,Define the iterator OO design pattern
2.4.10,task,Define the observer OO design pattern
2.4.11,task,Define the template method OO design pattern
2.5,task,Test and debug algorithms in C++
2.5,description,"The module explains general techniques to do unit testing and system testing, code inspection, printouts, logging and debugging in order to find bugs in algorithmic software."
2.5,reading,CH01P07;CH04P03
2.5,video,NA
2.5.1,task,Identify the reasons why software can contain errors
2.5.2,task,Write reasonably complete set of testcases. 
2.5.3,task,Enforce invariants and Hoare logic to your data structure manipulations
2.5.4,task,Use printouts and/or efficient logging
2.5.5,task,Analyze runtime behavior using breakpoints.
3,topic,Analyze the implementations of some data structures.
3.1,task,Construct and manipulate list-like data structures
3.1,description,"Define list and also vector (a.k.a. arraylist) allowing random access. In this and subsequent modules we start with the ADT we want, then show some ways to implement it."
3.1,reading,CH03P01;CH03P02;CH03P03;CH05P01;CH05P02;CH05P03;CH06P01;CH06P02;CH06P03
3.1,reading,https://bit.ly/31O7sWK
3.1,video,NA
3.1.1,task,Define list and vector ADTs
3.1.2,task,Define an iterator ADT
3.1.3,task,Implement list as a singly linked list
3.1.4,task,Implement list as a doubly linked list
3.1.5,task,Implement vector as an extendable array
3.1.6,task,Implement vector as an extendable cicular array
3.2,task,Construct and traverse tree-like data structures
3.2,description,"Trees in this course are always assumed to be rooted (one node is root) and ordered (we always know, which is the 1st, 2nd etc. child of the same parent). This module only deals with trees in the most general sense (to store certain hierarchies). Trees with additional structural requirements (with keys ordered for fast search and/or balanced) are called search trees; they will be discussed later. "
3.2,reading,CH07P01;CH07P02
3.2,video,NA
3.2.1,task,"Define graph-theoretic concepts: root, internal nodes, leaves, children, parent, siblings."
3.2.2,task,Define path-related concepts in trees
3.2.3,task,"Define full, complete and perfect n-ary trees."
3.2.4,task,Define tree ADT
3.2.5,task,Parse algebraic expressions and convert them to trees
3.2.6,task,Evaluate algebraic expression trees using stack data structure
3.2.7,task,Implement trees with two-way pointers
3.2.8,task,"Implement (preferably, complete) trees with arrays"
3.2.9,task,Representing a rooted n-ary tree as a binary tree.
3.3,task,Construct and manipulate priority queues and heaps
3.3,description,Unlike more universal structures (binary search trees or hashtables) the data structures may only need to return (or remove) the minimal or maximal element; in this case they are called priority queues. A typical way to implement them is a tree-like structure called a heap.
3.3,reading,CH08P01;CH08P02;CH08P03
3.3,video,NA
3.3.1,task,Priority queue ADT
3.3.2,task,Analyze priority queue implementation as a regular binomial heap
3.3.3,task,Analyze skew binomial heap implementation
3.3.4,task,Analyze leftist binomial heap implementation
3.3.5,task,Analyze Huffman algorithm to compress a sequence of independent messages
3.4,task,Construct and manipulate maps and dictionaries
3.4,description,Finding values by non-integer keys (typically strings) defines the difference between maps and lists. Dictionaries are a variant of maps allowing repeated keys. In this module the ADTs are defined and also their implementations 
3.4,reading,CH09P01;CH09P02;CH09P03;CH09P04
3.4,reading,https://bit.ly/31PBl91
3.4,reading,https://bit.ly/2Wzw6qD
3.4,video,NA
3.4.1,task,Define map ADT
3.4.2,task,Define a hashtable and a corresponding hash function
3.4.2.1,task,Describe a hash collision and hash tables with chaining
3.4.2.2,task,Growing and shrinking hash tables
3.4.2.3,task,Analyze worst-case and amortized operation complexity in hashtables
3.4.3,task,"Define a rolling hash ADT (append, skip)"
3.4.4,task,Analyze Rabin-Karp algorithm
3.4.5,task,Implement map as a doubly-linked list
3.4.6,task,Implement skiplists
3.4.7,task,Adjust data structures for dictionaries with repetitive keys
3.5,task,Construct and manipulate BST structures
3.5,description,Binary Search Trees is one possible way to store maps with totally ordered keys. This is an overview chapter that shows the general principles how the search trees can be built and manipulated. More flavors of BSTs are shown in the next module.
3.5,reading,CH01P01
3.5,video,NA
3.5.1,task,Define BST operations as ADT.
3.5.2,task,"Run node search, insert and delete in an abstract BST"
3.5.3,task,"Implement node search, insert and delete in pointer implementation."
3.5.4,task,"Implement node search, insert and delete in array implementation"
3.6,task,Construct and manipulate balanced BSTs
3.6,description,Inserting nodes in certain patterns can lead to skinny and inefficient trees. This module considers a few approaches 
3.6,reading,CH10P02;CH10P03;CH10P04;CH10P05
3.6,video,NA
3.6.1,task,Implement tree balancing as AVL tree
3.6.2,task,Implement tree balancing as red-black tree
3.6.3,task,Implement balancing as splay tree
3.6.4,task,"Introduce (a,b)-search-trees and (2,4)-trees in particular"
3.7,task,Analyze and compare sorting algorithms
3.7,description,This chapter describes general-purpose sorting algorithms (sorting also appears in STL module and as an illustration to various algorithm paradigms in later modules).
3.7,reading,CH11P01;CH11P02;CH11P03
3.7,video,NA
3.7.1,task,Analyze insertion sort and bubble sort
3.7.2,task,Analyze merge sort algorithm
3.7.3,task,Analyze quicksort algorithm
3.7.4,task,Analyze heapsort algorithm
3.8,task,Construct and manipulate set-like structures 
3.8,description,"This module explains ways to represent sets and also bags (allowing repetition of elements); their order relations and set-level operations. Element-level operations on sets were explained earlier – in fact, maps and dictionaries can be used for that."
3.8,reading,CH11P04;CH11P05
3.8,video,NA
3.8.1,task,Revisit generalized container ADTs that are used to represent (unordered) sets.
3.8.2,task,Introduce additional operations in ordered sets.
3.8.3,task,Revisit iterator ADTs in set-like data structures.
3.8.3.1,task,"Analyze set-level operations (union, difference, etc.) in the list implementation."
3.8.3.2,task,Analyze set-level operations in the hashtable implementation
3.8.3.3,task,Analyze set-level operations in tree implementations.
3.8.4,task,Analyze some algorithms for the selection problem (identifying the n-th element)
3.9,task,Describe graph and directed graph structures and traversals
3.9,description,The module explains the most complex data structures covered in this course (undirected and directed graphs); their ADT and some general tasks associated with graphs (such as BFS and DFS traversal). Any weighted graph issues are postponed. 
3.9,reading,CH13P01;CH13P02;CH13P03;CH13P04
3.9,video,NA
3.9.1,task,"Revisit graph concepts: undirected vs. directed, simple graphs vs. multigraphs, degrees, indegrees, outdegrees; their input via matrices and adjacency lists. "
3.9.2,task,"Introduce graph ADTs, their iterators, accessor and update methods. "
3.9.3,task,"Describe alternatives of graph input, output and storage."
3.9.4,task,Describe the BFS traversal algorithm template
3.9.5,task,Describe the DFS traversal algorithm flavors.
3.9.5.1,task,Use the DFS traversal to analyze mazes
3.9.5.2,task,Use the DFS traversal to find paths and cycles in a graph.
3.10,task,Analyze Shortest Paths and MST algorithms
3.10,description,Various general algorithmic ideas can be illustrated on weighted graph optimization problems. This module analyzes source-to-sink (or all-pairs) shortest paths and also the minimum spanning tree (MST) algorithms. 
3.10,reading,CH13P05;CH13P06
3.10,video,NA
3.10.1,task,Introduce the weighted graph framework and input data
3.10.2,task,Analyze Dijkstra’s algorithm
3.10.3,task,Analyze Bellman-Ford algorithm (and negative edge weights)
3.10.4,task,Analyze Kruskal’s algorithm
3.10.5,task,Analyze Prim’s algorithm
3.10.6,task,Analyze Boruvka’s algorithm
4,topic,Introduce general paradigms for algorithms.
4.1,task,Describe types of algorithmic problems and overview their algorithms
4.1,description,The last module provides a high-level overview of some large classes of algorithmic problems; what algorithms were covered in each one of them and what paradigms were used.
4.1,reading,CH12P03
4.1,video,NA
4.1.1,task,Describe searching and sorting problems
4.1.2,task,Describe string processing problems
4.1.3,task,Describe some examples of graph problems
4.1.4,task,Describe some examples of combinatorial problems
4.1.5,task,Describe some examples of geometric problems
4.1.6,task,Describe some examples of numerical problems
4.2,task,"Describe exhaustive, brute-force paradigms"
4.2,description,Introduce algorithms that split the problem into subcases and then verify subcases in some order
4.2,reading,CH12P03
4.2,video,NA
4.2.1,task,Define exhaustive search paradigm
4.2.2,task,Describe tactics to generate combinations
4.2.3,task,Describe examples of “naive” search algorithms
4.2.4,task,Describe examples of “naive” string matching algorithms
4.3,task,Describe decrease and conquer paradigm
4.3,description,Algorithm can reduce a problem to a simpler one. We discuss paradigms to solve a problem by stepwise reducing it to a simpler one.
4.3,reading,CH13P04
4.3,video,NA
4.3.1,task,Describe decrease and conquer paradigm
4.3.2,task,Revisit insertion sort algorithm
4.3.3,task,Analyze topological sorting algorithm
4.3.4,task,Generate permutations or subsets of a given set
4.3.5,task,Discuss heap implementations in terms of decrease and conquer.
4.4,task,Describe divide and conquer paradigm
4.4,description,Many algorithmic problems can be solved or “conquered” by subdividing them in parts
4.4,reading,CH11P01
4.4,video,NA
4.4.1,task,Describe divide and conquer paradigm
4.4.2,task,Revisit mergesort and quicksort
4.4.4,task,Revisit BSTs
4.4.4,task,"Analyze recurrence equations, apply Master method"
4.4.4.1,task,Run Karatsuba’s fast multiplication
4.4.4.2,task,Run Strassen’s fast matrix multiplication
4.5,task,Describe time and space tradeoffs
4.5,description,"In many cases algorithms can speed up, if they can use more space (or they can save space, if we allow more time)."
4.5,reading,CH14P03;CH14P04
4.5,video,NA
4.5.1,task,Describe the tradeoff between time and space complexity
4.5.2,task,Introduce input-enhancing approaches; analyze sorting-by-counting algorithms
4.5.3,task,Analyze tradeoffs in hashing algorithms and hashing function choices
4.5.4,task,Analyze Bloom filters; probabilistic dictionary implementations
4.5.4.1,task,Introduce sets of hash functions for Bloom filters
4.5.4.2,task,Describe the tradeoff between probabilistic data structure accuracy and space
4.5.5,task,Introduce B-tree data structure and its use in databases
4.6,task,Describe dynamic programming paradigm
4.6,description,Data structure manipulations are often a means to an end. Here we list some application areas that often lead to data structures; and this will help to introduce different algorithm creation paradigms – very general ideas that are behind the algorithm development.
4.6,reading,CH12P04
4.6,video,NA
4.6.1,task,Describe dynamic programming paradigm
4.6.2,task,Revisit shortest paths problems
4.6.3,task,Analyze optimal matrix multiplication problem
4.6.4,task,Analyze longest common subsequence algorithm
4.7,task,Describe greedy paradigm
4.7,description,"Some algorithms searching for the optimal (cheapest, fastest, etc.) way to complete the task follow the following rule: At every step select the “locally best” alternative and it will eventually lead to the globally best solution. This approach is usually efficient, but for many problem classes this could give a solution that is not the best possible."
4.7,reading,CH12P04
4.7,video,NA
4.7.1,task,Revisit Prim’s algorithm
4.7.2,task,Revisit Kruskal’s algorithm
4.7.3,task,Revisit Huffman’s algorithm
